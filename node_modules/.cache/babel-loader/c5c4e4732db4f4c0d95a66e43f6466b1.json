{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar _excluded = [\"resultsFacetValues\"],\n    _excluded2 = [\"resultsFacetValues\"],\n    _excluded3 = [\"resultsFacetValues\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport algoliasearchHelper from 'algoliasearch-helper';\nimport createWidgetsManager from \"./createWidgetsManager.js\";\nimport createStore from \"./createStore.js\";\nimport { HIGHLIGHT_TAGS } from \"./highlight.js\";\nimport { hasMultipleIndices } from \"./indexUtils.js\";\nimport { version as ReactVersion } from 'react';\nimport version from \"./version.js\";\n\nfunction addAlgoliaAgents(searchClient) {\n  if (typeof searchClient.addAlgoliaAgent === 'function') {\n    searchClient.addAlgoliaAgent(\"react (\".concat(ReactVersion, \")\"));\n    searchClient.addAlgoliaAgent(\"react-instantsearch (\".concat(version, \")\"));\n  }\n}\n\nvar isMultiIndexContext = function isMultiIndexContext(widget) {\n  return hasMultipleIndices({\n    ais: widget.props.contextValue,\n    multiIndexContext: widget.props.indexContextValue\n  });\n};\n\nvar isTargetedIndexEqualIndex = function isTargetedIndexEqualIndex(widget, indexId) {\n  return widget.props.indexContextValue.targetedIndex === indexId;\n}; // Relying on the `indexId` is a bit brittle to detect the `Index` widget.\n// Since it's a class we could rely on `instanceof` or similar. We never\n// had an issue though. Works for now.\n\n\nvar isIndexWidget = function isIndexWidget(widget) {\n  return Boolean(widget.props.indexId);\n};\n\nvar isIndexWidgetEqualIndex = function isIndexWidgetEqualIndex(widget, indexId) {\n  return widget.props.indexId === indexId;\n};\n\nvar sortIndexWidgetsFirst = function sortIndexWidgetsFirst(firstWidget, secondWidget) {\n  var isFirstWidgetIndex = isIndexWidget(firstWidget);\n  var isSecondWidgetIndex = isIndexWidget(secondWidget);\n\n  if (isFirstWidgetIndex && !isSecondWidgetIndex) {\n    return -1;\n  }\n\n  if (!isFirstWidgetIndex && isSecondWidgetIndex) {\n    return 1;\n  }\n\n  return 0;\n}; // This function is copied from the algoliasearch v4 API Client. If modified,\n// consider updating it also in `serializeQueryParameters` from `@algolia/transporter`.\n\n\nfunction serializeQueryParameters(parameters) {\n  var isObjectOrArray = function isObjectOrArray(value) {\n    return Object.prototype.toString.call(value) === '[object Object]' || Object.prototype.toString.call(value) === '[object Array]';\n  };\n\n  var encode = function encode(format) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var i = 0;\n    return format.replace(/%s/g, function () {\n      return encodeURIComponent(args[i++]);\n    });\n  };\n\n  return Object.keys(parameters).map(function (key) {\n    return encode('%s=%s', key, isObjectOrArray(parameters[key]) ? JSON.stringify(parameters[key]) : parameters[key]);\n  }).join('&');\n}\n/**\n * Creates a new instance of the InstantSearchManager which controls the widgets and\n * trigger the search when the widgets are updated.\n * @param {string} indexName - the main index name\n * @param {object} initialState - initial widget state\n * @param {object} SearchParameters - optional additional parameters to send to the algolia API\n * @param {number} stalledSearchDelay - time (in ms) after the search is stalled\n * @return {InstantSearchManager} a new instance of InstantSearchManager\n */\n\n\nexport default function createInstantSearchManager(_ref) {\n  var indexName = _ref.indexName,\n      _ref$initialState = _ref.initialState,\n      initialState = _ref$initialState === void 0 ? {} : _ref$initialState,\n      searchClient = _ref.searchClient,\n      resultsState = _ref.resultsState,\n      stalledSearchDelay = _ref.stalledSearchDelay;\n  var helper = algoliasearchHelper(searchClient, indexName, _objectSpread({}, HIGHLIGHT_TAGS));\n  addAlgoliaAgents(searchClient);\n  helper.on('search', handleNewSearch).on('result', handleSearchSuccess({\n    indexId: indexName\n  })).on('error', handleSearchError);\n  var skip = false;\n  var stalledSearchTimer = null;\n  var initialSearchParameters = helper.state;\n  var widgetsManager = createWidgetsManager(onWidgetsUpdate);\n  hydrateSearchClient(searchClient, resultsState);\n  var store = createStore({\n    widgets: initialState,\n    metadata: hydrateMetadata(resultsState),\n    results: hydrateResultsState(resultsState),\n    error: null,\n    searching: false,\n    isSearchStalled: true,\n    searchingForFacetValues: false\n  });\n\n  function skipSearch() {\n    skip = true;\n  }\n\n  function updateClient(client) {\n    addAlgoliaAgents(client);\n    helper.setClient(client);\n    search();\n  }\n\n  function clearCache() {\n    helper.clearCache();\n    search();\n  }\n\n  function getMetadata(state) {\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getMetadata);\n    }).map(function (widget) {\n      return widget.getMetadata(state);\n    });\n  }\n\n  function getSearchParameters() {\n    var sharedParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      return !isMultiIndexContext(widget) && !isIndexWidget(widget);\n    }).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, initialSearchParameters);\n    var mainParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexEqualMainIndex = isMultiIndexContext(widget) && isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexEqualMainIndex = isIndexWidget(widget) && isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexEqualMainIndex || subIndexEqualMainIndex;\n    }) // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, sharedParameters);\n    var derivedIndices = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexNotEqualMainIndex = isMultiIndexContext(widget) && !isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexNotEqualMainIndex = isIndexWidget(widget) && !isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexNotEqualMainIndex || subIndexNotEqualMainIndex;\n    }) // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (indices, widget) {\n      var indexId = isMultiIndexContext(widget) ? widget.props.indexContextValue.targetedIndex : widget.props.indexId;\n      var widgets = indices[indexId] || [];\n      return _objectSpread(_objectSpread({}, indices), {}, _defineProperty({}, indexId, widgets.concat(widget)));\n    }, {});\n    var derivedParameters = Object.keys(derivedIndices).map(function (indexId) {\n      return {\n        parameters: derivedIndices[indexId].reduce(function (res, widget) {\n          return widget.getSearchParameters(res);\n        }, sharedParameters),\n        indexId: indexId\n      };\n    });\n    return {\n      mainParameters: mainParameters,\n      derivedParameters: derivedParameters\n    };\n  }\n\n  function search() {\n    if (!skip) {\n      var _getSearchParameters = getSearchParameters(helper.state),\n          mainParameters = _getSearchParameters.mainParameters,\n          derivedParameters = _getSearchParameters.derivedParameters; // We have to call `slice` because the method `detach` on the derived\n      // helpers mutates the value `derivedHelpers`. The `forEach` loop does\n      // not iterate on each value and we're not able to correctly clear the\n      // previous derived helpers (memory leak + useless requests).\n\n\n      helper.derivedHelpers.slice().forEach(function (derivedHelper) {\n        // Since we detach the derived helpers on **every** new search they\n        // won't receive intermediate results in case of a stalled search.\n        // Only the last result is dispatched by the derived helper because\n        // they are not detached yet:\n        //\n        // - a -> main helper receives results\n        // - ap -> main helper receives results\n        // - app -> main helper + derived helpers receive results\n        //\n        // The quick fix is to avoid to detach them on search but only once they\n        // received the results. But it means that in case of a stalled search\n        // all the derived helpers not detached yet register a new search inside\n        // the helper. The number grows fast in case of a bad network and it's\n        // not deterministic.\n        derivedHelper.detach();\n      });\n      derivedParameters.forEach(function (_ref2) {\n        var indexId = _ref2.indexId,\n            parameters = _ref2.parameters;\n        var derivedHelper = helper.derive(function () {\n          return parameters;\n        });\n        derivedHelper.on('result', handleSearchSuccess({\n          indexId: indexId\n        })).on('error', handleSearchError);\n      });\n      helper.setState(mainParameters);\n      helper.search();\n    }\n  }\n\n  function handleSearchSuccess(_ref3) {\n    var indexId = _ref3.indexId;\n    return function (event) {\n      var state = store.getState();\n      var isDerivedHelpersEmpty = !helper.derivedHelpers.length;\n      var results = state.results ? state.results : {}; // Switching from mono index to multi index and vice versa must reset the\n      // results to an empty object, otherwise we keep reference of stalled and\n      // unused results.\n\n      results = !isDerivedHelpersEmpty && results.getFacetByName ? {} : results;\n\n      if (!isDerivedHelpersEmpty) {\n        results = _objectSpread(_objectSpread({}, results), {}, _defineProperty({}, indexId, event.results));\n      } else {\n        results = event.results;\n      }\n\n      var currentState = store.getState();\n      var nextIsSearchStalled = currentState.isSearchStalled;\n\n      if (!helper.hasPendingRequests()) {\n        clearTimeout(stalledSearchTimer);\n        stalledSearchTimer = null;\n        nextIsSearchStalled = false;\n      }\n\n      var resultsFacetValues = currentState.resultsFacetValues,\n          partialState = _objectWithoutProperties(currentState, _excluded);\n\n      store.setState(_objectSpread(_objectSpread({}, partialState), {}, {\n        results: results,\n        isSearchStalled: nextIsSearchStalled,\n        searching: false,\n        error: null\n      }));\n    };\n  }\n\n  function handleSearchError(_ref4) {\n    var error = _ref4.error;\n    var currentState = store.getState();\n    var nextIsSearchStalled = currentState.isSearchStalled;\n\n    if (!helper.hasPendingRequests()) {\n      clearTimeout(stalledSearchTimer);\n      nextIsSearchStalled = false;\n    }\n\n    var resultsFacetValues = currentState.resultsFacetValues,\n        partialState = _objectWithoutProperties(currentState, _excluded2);\n\n    store.setState(_objectSpread(_objectSpread({}, partialState), {}, {\n      isSearchStalled: nextIsSearchStalled,\n      error: error,\n      searching: false\n    }));\n  }\n\n  function handleNewSearch() {\n    if (!stalledSearchTimer) {\n      stalledSearchTimer = setTimeout(function () {\n        var _store$getState = store.getState(),\n            resultsFacetValues = _store$getState.resultsFacetValues,\n            partialState = _objectWithoutProperties(_store$getState, _excluded3);\n\n        store.setState(_objectSpread(_objectSpread({}, partialState), {}, {\n          isSearchStalled: true\n        }));\n      }, stalledSearchDelay);\n    }\n  }\n\n  function hydrateSearchClient(client, results) {\n    if (!results) {\n      return;\n    } // Disable cache hydration on:\n    // - Algoliasearch API Client < v4 with cache disabled\n    // - Third party clients (detected by the `addAlgoliaAgent` function missing)\n\n\n    if ((!client.transporter || client._cacheHydrated) && (!client._useCache || typeof client.addAlgoliaAgent !== 'function')) {\n      return;\n    } // Algoliasearch API Client >= v4\n    // To hydrate the client we need to populate the cache with the data from\n    // the server (done in `hydrateSearchClientWithMultiIndexRequest` or\n    // `hydrateSearchClientWithSingleIndexRequest`). But since there is no way\n    // for us to compute the key the same way as `algoliasearch-client` we need\n    // to populate it on a custom key and override the `search` method to\n    // search on it first.\n\n\n    if (client.transporter && !client._cacheHydrated) {\n      client._cacheHydrated = true;\n      var baseMethod = client.search;\n\n      client.search = function (requests) {\n        for (var _len2 = arguments.length, methodArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          methodArgs[_key2 - 1] = arguments[_key2];\n        }\n\n        var requestsWithSerializedParams = requests.map(function (request) {\n          return _objectSpread(_objectSpread({}, request), {}, {\n            params: serializeQueryParameters(request.params)\n          });\n        });\n        return client.transporter.responsesCache.get({\n          method: 'search',\n          args: [requestsWithSerializedParams].concat(methodArgs)\n        }, function () {\n          return baseMethod.apply(void 0, [requests].concat(methodArgs));\n        });\n      };\n    }\n\n    if (Array.isArray(results.results)) {\n      hydrateSearchClientWithMultiIndexRequest(client, results.results);\n      return;\n    }\n\n    hydrateSearchClientWithSingleIndexRequest(client, results);\n  }\n\n  function hydrateSearchClientWithMultiIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults.map(function (request) {\n            return {\n              indexName: request.index,\n              params: request.params\n            };\n          }));\n        }, [])]\n      }, {\n        results: results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults);\n        }, [])\n      });\n      return;\n    } // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n\n\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        }));\n      }, [])\n    }));\n    client.cache = _objectSpread(_objectSpread({}, client.cache), {}, _defineProperty({}, key, JSON.stringify({\n      results: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults);\n      }, [])\n    })));\n  }\n\n  function hydrateSearchClientWithSingleIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        })]\n      }, {\n        results: results.rawResults\n      });\n      return;\n    } // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n\n\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.rawResults.map(function (request) {\n        return {\n          indexName: request.index,\n          params: request.params\n        };\n      })\n    }));\n    client.cache = _objectSpread(_objectSpread({}, client.cache), {}, _defineProperty({}, key, JSON.stringify({\n      results: results.rawResults\n    })));\n  }\n\n  function hydrateResultsState(results) {\n    if (!results) {\n      return null;\n    }\n\n    if (Array.isArray(results.results)) {\n      return results.results.reduce(function (acc, result) {\n        return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, result._internalIndexId, new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(result.state), result.rawResults)));\n      }, {});\n    }\n\n    return new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(results.state), results.rawResults);\n  } // Called whenever a widget has been rendered with new props.\n\n\n  function onWidgetsUpdate() {\n    var metadata = getMetadata(store.getState().widgets);\n    store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n      metadata: metadata,\n      searching: true\n    })); // Since the `getSearchParameters` method of widgets also depends on props,\n    // the result search parameters might have changed.\n\n    search();\n  }\n\n  function transitionState(nextSearchState) {\n    var searchState = store.getState().widgets;\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.transitionState);\n    }).reduce(function (res, widget) {\n      return widget.transitionState(searchState, res);\n    }, nextSearchState);\n  }\n\n  function onExternalStateUpdate(nextSearchState) {\n    var metadata = getMetadata(nextSearchState);\n    store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n      widgets: nextSearchState,\n      metadata: metadata,\n      searching: true\n    }));\n    search();\n  }\n\n  function onSearchForFacetValues(_ref5) {\n    var facetName = _ref5.facetName,\n        query = _ref5.query,\n        _ref5$maxFacetHits = _ref5.maxFacetHits,\n        maxFacetHits = _ref5$maxFacetHits === void 0 ? 10 : _ref5$maxFacetHits; // The values 1, 100 are the min / max values that the engine accepts.\n    // see: https://www.algolia.com/doc/api-reference/api-parameters/maxFacetHits\n\n    var maxFacetHitsWithinRange = Math.max(1, Math.min(maxFacetHits, 100));\n    store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n      searchingForFacetValues: true\n    }));\n    helper.searchForFacetValues(facetName, query, maxFacetHitsWithinRange).then(function (content) {\n      var _objectSpread7;\n\n      store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n        error: null,\n        searchingForFacetValues: false,\n        resultsFacetValues: _objectSpread(_objectSpread({}, store.getState().resultsFacetValues), {}, (_objectSpread7 = {}, _defineProperty(_objectSpread7, facetName, content.facetHits), _defineProperty(_objectSpread7, \"query\", query), _objectSpread7))\n      }));\n    }, function (error) {\n      store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n        searchingForFacetValues: false,\n        error: error\n      }));\n    }).catch(function (error) {\n      // Since setState is synchronous, any error that occurs in the render of a\n      // component will be swallowed by this promise.\n      // This is a trick to make the error show up correctly in the console.\n      // See http://stackoverflow.com/a/30741722/969302\n      setTimeout(function () {\n        throw error;\n      });\n    });\n  }\n\n  function updateIndex(newIndex) {\n    initialSearchParameters = initialSearchParameters.setIndex(newIndex); // No need to trigger a new search here as the widgets will also update and trigger it if needed.\n  }\n\n  function getWidgetsIds() {\n    return store.getState().metadata.reduce(function (res, meta) {\n      return typeof meta.id !== 'undefined' ? res.concat(meta.id) : res;\n    }, []);\n  }\n\n  return {\n    store: store,\n    widgetsManager: widgetsManager,\n    getWidgetsIds: getWidgetsIds,\n    getSearchParameters: getSearchParameters,\n    onSearchForFacetValues: onSearchForFacetValues,\n    onExternalStateUpdate: onExternalStateUpdate,\n    transitionState: transitionState,\n    updateClient: updateClient,\n    updateIndex: updateIndex,\n    clearCache: clearCache,\n    skipSearch: skipSearch\n  };\n}\n\nfunction hydrateMetadata(resultsState) {\n  if (!resultsState) {\n    return [];\n  } // add a value noop, which gets replaced once the widgets are mounted\n\n\n  return resultsState.metadata.map(function (datum) {\n    return _objectSpread(_objectSpread({\n      value: function value() {\n        return {};\n      }\n    }, datum), {}, {\n      items: datum.items && datum.items.map(function (item) {\n        return _objectSpread(_objectSpread({\n          value: function value() {\n            return {};\n          }\n        }, item), {}, {\n          items: item.items && item.items.map(function (nestedItem) {\n            return _objectSpread({\n              value: function value() {\n                return {};\n              }\n            }, nestedItem);\n          })\n        });\n      })\n    });\n  });\n}","map":{"version":3,"sources":["/Users/tingting/code/tin2294/repository-search/node_modules/react-instantsearch-core/dist/es/core/createInstantSearchManager.js"],"names":["_objectWithoutProperties","_defineProperty","_excluded","_excluded2","_excluded3","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","algoliasearchHelper","createWidgetsManager","createStore","HIGHLIGHT_TAGS","hasMultipleIndices","version","ReactVersion","addAlgoliaAgents","searchClient","addAlgoliaAgent","concat","isMultiIndexContext","widget","ais","props","contextValue","multiIndexContext","indexContextValue","isTargetedIndexEqualIndex","indexId","targetedIndex","isIndexWidget","Boolean","isIndexWidgetEqualIndex","sortIndexWidgetsFirst","firstWidget","secondWidget","isFirstWidgetIndex","isSecondWidgetIndex","serializeQueryParameters","parameters","isObjectOrArray","value","prototype","toString","call","encode","format","_len","args","Array","_key","replace","encodeURIComponent","map","JSON","stringify","join","createInstantSearchManager","_ref","indexName","_ref$initialState","initialState","resultsState","stalledSearchDelay","helper","on","handleNewSearch","handleSearchSuccess","handleSearchError","skip","stalledSearchTimer","initialSearchParameters","state","widgetsManager","onWidgetsUpdate","hydrateSearchClient","store","widgets","metadata","hydrateMetadata","results","hydrateResultsState","error","searching","isSearchStalled","searchingForFacetValues","skipSearch","updateClient","client","setClient","search","clearCache","getMetadata","getWidgets","getSearchParameters","sharedParameters","reduce","res","mainParameters","targetedIndexEqualMainIndex","subIndexEqualMainIndex","sort","derivedIndices","targetedIndexNotEqualMainIndex","subIndexNotEqualMainIndex","indices","derivedParameters","_getSearchParameters","derivedHelpers","slice","derivedHelper","detach","_ref2","derive","setState","_ref3","event","getState","isDerivedHelpersEmpty","getFacetByName","currentState","nextIsSearchStalled","hasPendingRequests","clearTimeout","resultsFacetValues","partialState","_ref4","setTimeout","_store$getState","transporter","_cacheHydrated","_useCache","baseMethod","requests","_len2","methodArgs","_key2","requestsWithSerializedParams","request","params","responsesCache","get","method","isArray","hydrateSearchClientWithMultiIndexRequest","hydrateSearchClientWithSingleIndexRequest","set","acc","result","rawResults","index","cache","_internalIndexId","SearchResults","SearchParameters","transitionState","nextSearchState","searchState","onExternalStateUpdate","onSearchForFacetValues","_ref5","facetName","query","_ref5$maxFacetHits","maxFacetHits","maxFacetHitsWithinRange","Math","max","min","searchForFacetValues","then","content","_objectSpread7","facetHits","catch","updateIndex","newIndex","setIndex","getWidgetsIds","meta","id","datum","items","item","nestedItem"],"mappings":"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","sourcesContent":["import _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar _excluded = [\"resultsFacetValues\"],\n    _excluded2 = [\"resultsFacetValues\"],\n    _excluded3 = [\"resultsFacetValues\"];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport algoliasearchHelper from 'algoliasearch-helper';\nimport createWidgetsManager from \"./createWidgetsManager.js\";\nimport createStore from \"./createStore.js\";\nimport { HIGHLIGHT_TAGS } from \"./highlight.js\";\nimport { hasMultipleIndices } from \"./indexUtils.js\";\nimport { version as ReactVersion } from 'react';\nimport version from \"./version.js\";\n\nfunction addAlgoliaAgents(searchClient) {\n  if (typeof searchClient.addAlgoliaAgent === 'function') {\n    searchClient.addAlgoliaAgent(\"react (\".concat(ReactVersion, \")\"));\n    searchClient.addAlgoliaAgent(\"react-instantsearch (\".concat(version, \")\"));\n  }\n}\n\nvar isMultiIndexContext = function isMultiIndexContext(widget) {\n  return hasMultipleIndices({\n    ais: widget.props.contextValue,\n    multiIndexContext: widget.props.indexContextValue\n  });\n};\n\nvar isTargetedIndexEqualIndex = function isTargetedIndexEqualIndex(widget, indexId) {\n  return widget.props.indexContextValue.targetedIndex === indexId;\n}; // Relying on the `indexId` is a bit brittle to detect the `Index` widget.\n// Since it's a class we could rely on `instanceof` or similar. We never\n// had an issue though. Works for now.\n\n\nvar isIndexWidget = function isIndexWidget(widget) {\n  return Boolean(widget.props.indexId);\n};\n\nvar isIndexWidgetEqualIndex = function isIndexWidgetEqualIndex(widget, indexId) {\n  return widget.props.indexId === indexId;\n};\n\nvar sortIndexWidgetsFirst = function sortIndexWidgetsFirst(firstWidget, secondWidget) {\n  var isFirstWidgetIndex = isIndexWidget(firstWidget);\n  var isSecondWidgetIndex = isIndexWidget(secondWidget);\n\n  if (isFirstWidgetIndex && !isSecondWidgetIndex) {\n    return -1;\n  }\n\n  if (!isFirstWidgetIndex && isSecondWidgetIndex) {\n    return 1;\n  }\n\n  return 0;\n}; // This function is copied from the algoliasearch v4 API Client. If modified,\n// consider updating it also in `serializeQueryParameters` from `@algolia/transporter`.\n\n\nfunction serializeQueryParameters(parameters) {\n  var isObjectOrArray = function isObjectOrArray(value) {\n    return Object.prototype.toString.call(value) === '[object Object]' || Object.prototype.toString.call(value) === '[object Array]';\n  };\n\n  var encode = function encode(format) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var i = 0;\n    return format.replace(/%s/g, function () {\n      return encodeURIComponent(args[i++]);\n    });\n  };\n\n  return Object.keys(parameters).map(function (key) {\n    return encode('%s=%s', key, isObjectOrArray(parameters[key]) ? JSON.stringify(parameters[key]) : parameters[key]);\n  }).join('&');\n}\n/**\n * Creates a new instance of the InstantSearchManager which controls the widgets and\n * trigger the search when the widgets are updated.\n * @param {string} indexName - the main index name\n * @param {object} initialState - initial widget state\n * @param {object} SearchParameters - optional additional parameters to send to the algolia API\n * @param {number} stalledSearchDelay - time (in ms) after the search is stalled\n * @return {InstantSearchManager} a new instance of InstantSearchManager\n */\n\n\nexport default function createInstantSearchManager(_ref) {\n  var indexName = _ref.indexName,\n      _ref$initialState = _ref.initialState,\n      initialState = _ref$initialState === void 0 ? {} : _ref$initialState,\n      searchClient = _ref.searchClient,\n      resultsState = _ref.resultsState,\n      stalledSearchDelay = _ref.stalledSearchDelay;\n  var helper = algoliasearchHelper(searchClient, indexName, _objectSpread({}, HIGHLIGHT_TAGS));\n  addAlgoliaAgents(searchClient);\n  helper.on('search', handleNewSearch).on('result', handleSearchSuccess({\n    indexId: indexName\n  })).on('error', handleSearchError);\n  var skip = false;\n  var stalledSearchTimer = null;\n  var initialSearchParameters = helper.state;\n  var widgetsManager = createWidgetsManager(onWidgetsUpdate);\n  hydrateSearchClient(searchClient, resultsState);\n  var store = createStore({\n    widgets: initialState,\n    metadata: hydrateMetadata(resultsState),\n    results: hydrateResultsState(resultsState),\n    error: null,\n    searching: false,\n    isSearchStalled: true,\n    searchingForFacetValues: false\n  });\n\n  function skipSearch() {\n    skip = true;\n  }\n\n  function updateClient(client) {\n    addAlgoliaAgents(client);\n    helper.setClient(client);\n    search();\n  }\n\n  function clearCache() {\n    helper.clearCache();\n    search();\n  }\n\n  function getMetadata(state) {\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getMetadata);\n    }).map(function (widget) {\n      return widget.getMetadata(state);\n    });\n  }\n\n  function getSearchParameters() {\n    var sharedParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      return !isMultiIndexContext(widget) && !isIndexWidget(widget);\n    }).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, initialSearchParameters);\n    var mainParameters = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexEqualMainIndex = isMultiIndexContext(widget) && isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexEqualMainIndex = isIndexWidget(widget) && isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexEqualMainIndex || subIndexEqualMainIndex;\n    }) // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (res, widget) {\n      return widget.getSearchParameters(res);\n    }, sharedParameters);\n    var derivedIndices = widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.getSearchParameters);\n    }).filter(function (widget) {\n      var targetedIndexNotEqualMainIndex = isMultiIndexContext(widget) && !isTargetedIndexEqualIndex(widget, indexName);\n      var subIndexNotEqualMainIndex = isIndexWidget(widget) && !isIndexWidgetEqualIndex(widget, indexName);\n      return targetedIndexNotEqualMainIndex || subIndexNotEqualMainIndex;\n    }) // We have to sort the `Index` widgets first so the `index` parameter\n    // is correctly set in the `reduce` function for the following widgets\n    .sort(sortIndexWidgetsFirst).reduce(function (indices, widget) {\n      var indexId = isMultiIndexContext(widget) ? widget.props.indexContextValue.targetedIndex : widget.props.indexId;\n      var widgets = indices[indexId] || [];\n      return _objectSpread(_objectSpread({}, indices), {}, _defineProperty({}, indexId, widgets.concat(widget)));\n    }, {});\n    var derivedParameters = Object.keys(derivedIndices).map(function (indexId) {\n      return {\n        parameters: derivedIndices[indexId].reduce(function (res, widget) {\n          return widget.getSearchParameters(res);\n        }, sharedParameters),\n        indexId: indexId\n      };\n    });\n    return {\n      mainParameters: mainParameters,\n      derivedParameters: derivedParameters\n    };\n  }\n\n  function search() {\n    if (!skip) {\n      var _getSearchParameters = getSearchParameters(helper.state),\n          mainParameters = _getSearchParameters.mainParameters,\n          derivedParameters = _getSearchParameters.derivedParameters; // We have to call `slice` because the method `detach` on the derived\n      // helpers mutates the value `derivedHelpers`. The `forEach` loop does\n      // not iterate on each value and we're not able to correctly clear the\n      // previous derived helpers (memory leak + useless requests).\n\n\n      helper.derivedHelpers.slice().forEach(function (derivedHelper) {\n        // Since we detach the derived helpers on **every** new search they\n        // won't receive intermediate results in case of a stalled search.\n        // Only the last result is dispatched by the derived helper because\n        // they are not detached yet:\n        //\n        // - a -> main helper receives results\n        // - ap -> main helper receives results\n        // - app -> main helper + derived helpers receive results\n        //\n        // The quick fix is to avoid to detach them on search but only once they\n        // received the results. But it means that in case of a stalled search\n        // all the derived helpers not detached yet register a new search inside\n        // the helper. The number grows fast in case of a bad network and it's\n        // not deterministic.\n        derivedHelper.detach();\n      });\n      derivedParameters.forEach(function (_ref2) {\n        var indexId = _ref2.indexId,\n            parameters = _ref2.parameters;\n        var derivedHelper = helper.derive(function () {\n          return parameters;\n        });\n        derivedHelper.on('result', handleSearchSuccess({\n          indexId: indexId\n        })).on('error', handleSearchError);\n      });\n      helper.setState(mainParameters);\n      helper.search();\n    }\n  }\n\n  function handleSearchSuccess(_ref3) {\n    var indexId = _ref3.indexId;\n    return function (event) {\n      var state = store.getState();\n      var isDerivedHelpersEmpty = !helper.derivedHelpers.length;\n      var results = state.results ? state.results : {}; // Switching from mono index to multi index and vice versa must reset the\n      // results to an empty object, otherwise we keep reference of stalled and\n      // unused results.\n\n      results = !isDerivedHelpersEmpty && results.getFacetByName ? {} : results;\n\n      if (!isDerivedHelpersEmpty) {\n        results = _objectSpread(_objectSpread({}, results), {}, _defineProperty({}, indexId, event.results));\n      } else {\n        results = event.results;\n      }\n\n      var currentState = store.getState();\n      var nextIsSearchStalled = currentState.isSearchStalled;\n\n      if (!helper.hasPendingRequests()) {\n        clearTimeout(stalledSearchTimer);\n        stalledSearchTimer = null;\n        nextIsSearchStalled = false;\n      }\n\n      var resultsFacetValues = currentState.resultsFacetValues,\n          partialState = _objectWithoutProperties(currentState, _excluded);\n\n      store.setState(_objectSpread(_objectSpread({}, partialState), {}, {\n        results: results,\n        isSearchStalled: nextIsSearchStalled,\n        searching: false,\n        error: null\n      }));\n    };\n  }\n\n  function handleSearchError(_ref4) {\n    var error = _ref4.error;\n    var currentState = store.getState();\n    var nextIsSearchStalled = currentState.isSearchStalled;\n\n    if (!helper.hasPendingRequests()) {\n      clearTimeout(stalledSearchTimer);\n      nextIsSearchStalled = false;\n    }\n\n    var resultsFacetValues = currentState.resultsFacetValues,\n        partialState = _objectWithoutProperties(currentState, _excluded2);\n\n    store.setState(_objectSpread(_objectSpread({}, partialState), {}, {\n      isSearchStalled: nextIsSearchStalled,\n      error: error,\n      searching: false\n    }));\n  }\n\n  function handleNewSearch() {\n    if (!stalledSearchTimer) {\n      stalledSearchTimer = setTimeout(function () {\n        var _store$getState = store.getState(),\n            resultsFacetValues = _store$getState.resultsFacetValues,\n            partialState = _objectWithoutProperties(_store$getState, _excluded3);\n\n        store.setState(_objectSpread(_objectSpread({}, partialState), {}, {\n          isSearchStalled: true\n        }));\n      }, stalledSearchDelay);\n    }\n  }\n\n  function hydrateSearchClient(client, results) {\n    if (!results) {\n      return;\n    } // Disable cache hydration on:\n    // - Algoliasearch API Client < v4 with cache disabled\n    // - Third party clients (detected by the `addAlgoliaAgent` function missing)\n\n\n    if ((!client.transporter || client._cacheHydrated) && (!client._useCache || typeof client.addAlgoliaAgent !== 'function')) {\n      return;\n    } // Algoliasearch API Client >= v4\n    // To hydrate the client we need to populate the cache with the data from\n    // the server (done in `hydrateSearchClientWithMultiIndexRequest` or\n    // `hydrateSearchClientWithSingleIndexRequest`). But since there is no way\n    // for us to compute the key the same way as `algoliasearch-client` we need\n    // to populate it on a custom key and override the `search` method to\n    // search on it first.\n\n\n    if (client.transporter && !client._cacheHydrated) {\n      client._cacheHydrated = true;\n      var baseMethod = client.search;\n\n      client.search = function (requests) {\n        for (var _len2 = arguments.length, methodArgs = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          methodArgs[_key2 - 1] = arguments[_key2];\n        }\n\n        var requestsWithSerializedParams = requests.map(function (request) {\n          return _objectSpread(_objectSpread({}, request), {}, {\n            params: serializeQueryParameters(request.params)\n          });\n        });\n        return client.transporter.responsesCache.get({\n          method: 'search',\n          args: [requestsWithSerializedParams].concat(methodArgs)\n        }, function () {\n          return baseMethod.apply(void 0, [requests].concat(methodArgs));\n        });\n      };\n    }\n\n    if (Array.isArray(results.results)) {\n      hydrateSearchClientWithMultiIndexRequest(client, results.results);\n      return;\n    }\n\n    hydrateSearchClientWithSingleIndexRequest(client, results);\n  }\n\n  function hydrateSearchClientWithMultiIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults.map(function (request) {\n            return {\n              indexName: request.index,\n              params: request.params\n            };\n          }));\n        }, [])]\n      }, {\n        results: results.reduce(function (acc, result) {\n          return acc.concat(result.rawResults);\n        }, [])\n      });\n      return;\n    } // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n\n\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        }));\n      }, [])\n    }));\n    client.cache = _objectSpread(_objectSpread({}, client.cache), {}, _defineProperty({}, key, JSON.stringify({\n      results: results.reduce(function (acc, result) {\n        return acc.concat(result.rawResults);\n      }, [])\n    })));\n  }\n\n  function hydrateSearchClientWithSingleIndexRequest(client, results) {\n    // Algoliasearch API Client >= v4\n    // Populate the cache with the data from the server\n    if (client.transporter) {\n      client.transporter.responsesCache.set({\n        method: 'search',\n        args: [results.rawResults.map(function (request) {\n          return {\n            indexName: request.index,\n            params: request.params\n          };\n        })]\n      }, {\n        results: results.rawResults\n      });\n      return;\n    } // Algoliasearch API Client < v4\n    // Prior to client v4 we didn't have a proper API to hydrate the client\n    // cache from the outside. The following code populates the cache with\n    // a single-index result. You can find more information about the\n    // computation of the key inside the client (see link below).\n    // https://github.com/algolia/algoliasearch-client-javascript/blob/c27e89ff92b2a854ae6f40dc524bffe0f0cbc169/src/AlgoliaSearchCore.js#L232-L240\n\n\n    var key = \"/1/indexes/*/queries_body_\".concat(JSON.stringify({\n      requests: results.rawResults.map(function (request) {\n        return {\n          indexName: request.index,\n          params: request.params\n        };\n      })\n    }));\n    client.cache = _objectSpread(_objectSpread({}, client.cache), {}, _defineProperty({}, key, JSON.stringify({\n      results: results.rawResults\n    })));\n  }\n\n  function hydrateResultsState(results) {\n    if (!results) {\n      return null;\n    }\n\n    if (Array.isArray(results.results)) {\n      return results.results.reduce(function (acc, result) {\n        return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, result._internalIndexId, new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(result.state), result.rawResults)));\n      }, {});\n    }\n\n    return new algoliasearchHelper.SearchResults(new algoliasearchHelper.SearchParameters(results.state), results.rawResults);\n  } // Called whenever a widget has been rendered with new props.\n\n\n  function onWidgetsUpdate() {\n    var metadata = getMetadata(store.getState().widgets);\n    store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n      metadata: metadata,\n      searching: true\n    })); // Since the `getSearchParameters` method of widgets also depends on props,\n    // the result search parameters might have changed.\n\n    search();\n  }\n\n  function transitionState(nextSearchState) {\n    var searchState = store.getState().widgets;\n    return widgetsManager.getWidgets().filter(function (widget) {\n      return Boolean(widget.transitionState);\n    }).reduce(function (res, widget) {\n      return widget.transitionState(searchState, res);\n    }, nextSearchState);\n  }\n\n  function onExternalStateUpdate(nextSearchState) {\n    var metadata = getMetadata(nextSearchState);\n    store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n      widgets: nextSearchState,\n      metadata: metadata,\n      searching: true\n    }));\n    search();\n  }\n\n  function onSearchForFacetValues(_ref5) {\n    var facetName = _ref5.facetName,\n        query = _ref5.query,\n        _ref5$maxFacetHits = _ref5.maxFacetHits,\n        maxFacetHits = _ref5$maxFacetHits === void 0 ? 10 : _ref5$maxFacetHits;\n    // The values 1, 100 are the min / max values that the engine accepts.\n    // see: https://www.algolia.com/doc/api-reference/api-parameters/maxFacetHits\n    var maxFacetHitsWithinRange = Math.max(1, Math.min(maxFacetHits, 100));\n    store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n      searchingForFacetValues: true\n    }));\n    helper.searchForFacetValues(facetName, query, maxFacetHitsWithinRange).then(function (content) {\n      var _objectSpread7;\n\n      store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n        error: null,\n        searchingForFacetValues: false,\n        resultsFacetValues: _objectSpread(_objectSpread({}, store.getState().resultsFacetValues), {}, (_objectSpread7 = {}, _defineProperty(_objectSpread7, facetName, content.facetHits), _defineProperty(_objectSpread7, \"query\", query), _objectSpread7))\n      }));\n    }, function (error) {\n      store.setState(_objectSpread(_objectSpread({}, store.getState()), {}, {\n        searchingForFacetValues: false,\n        error: error\n      }));\n    }).catch(function (error) {\n      // Since setState is synchronous, any error that occurs in the render of a\n      // component will be swallowed by this promise.\n      // This is a trick to make the error show up correctly in the console.\n      // See http://stackoverflow.com/a/30741722/969302\n      setTimeout(function () {\n        throw error;\n      });\n    });\n  }\n\n  function updateIndex(newIndex) {\n    initialSearchParameters = initialSearchParameters.setIndex(newIndex); // No need to trigger a new search here as the widgets will also update and trigger it if needed.\n  }\n\n  function getWidgetsIds() {\n    return store.getState().metadata.reduce(function (res, meta) {\n      return typeof meta.id !== 'undefined' ? res.concat(meta.id) : res;\n    }, []);\n  }\n\n  return {\n    store: store,\n    widgetsManager: widgetsManager,\n    getWidgetsIds: getWidgetsIds,\n    getSearchParameters: getSearchParameters,\n    onSearchForFacetValues: onSearchForFacetValues,\n    onExternalStateUpdate: onExternalStateUpdate,\n    transitionState: transitionState,\n    updateClient: updateClient,\n    updateIndex: updateIndex,\n    clearCache: clearCache,\n    skipSearch: skipSearch\n  };\n}\n\nfunction hydrateMetadata(resultsState) {\n  if (!resultsState) {\n    return [];\n  } // add a value noop, which gets replaced once the widgets are mounted\n\n\n  return resultsState.metadata.map(function (datum) {\n    return _objectSpread(_objectSpread({\n      value: function value() {\n        return {};\n      }\n    }, datum), {}, {\n      items: datum.items && datum.items.map(function (item) {\n        return _objectSpread(_objectSpread({\n          value: function value() {\n            return {};\n          }\n        }, item), {}, {\n          items: item.items && item.items.map(function (nestedItem) {\n            return _objectSpread({\n              value: function value() {\n                return {};\n              }\n            }, nestedItem);\n          })\n        });\n      })\n    });\n  });\n}"]},"metadata":{},"sourceType":"module"}