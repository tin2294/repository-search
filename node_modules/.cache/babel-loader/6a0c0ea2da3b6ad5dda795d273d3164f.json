{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { omit } from \"./utils.js\";\nexport function getIndexId(context) {\n  return hasMultipleIndices(context) ? context.multiIndexContext.targetedIndex : context.ais.mainTargetedIndex;\n}\n/**\n * @returns {import('algoliasearch-helper').SearchResults} results\n */\n\nexport function getResults(searchResults, context) {\n  if (searchResults.results) {\n    if (searchResults.results.hits) {\n      return searchResults.results;\n    }\n\n    var indexId = getIndexId(context);\n\n    if (searchResults.results[indexId]) {\n      return searchResults.results[indexId];\n    }\n  }\n\n  return null;\n}\nexport function hasMultipleIndices(context) {\n  return context && context.multiIndexContext;\n}\nexport function refineValue(searchState, nextRefinement, context, resetPage, namespace) {\n  if (hasMultipleIndices(context)) {\n    var indexId = getIndexId(context);\n    return namespace ? refineMultiIndexWithNamespace(searchState, nextRefinement, indexId, resetPage, namespace) : refineMultiIndex(searchState, nextRefinement, indexId, resetPage);\n  } else {\n    // When we have a multi index page with shared widgets we should also\n    // reset their page to 1 if the resetPage is provided. Otherwise the\n    // indices will always be reset\n    // see: https://github.com/algolia/react-instantsearch/issues/310\n    // see: https://github.com/algolia/react-instantsearch/issues/637\n    if (searchState.indices && resetPage) {\n      Object.keys(searchState.indices).forEach(function (targetedIndex) {\n        searchState = refineValue(searchState, {\n          page: 1\n        }, {\n          multiIndexContext: {\n            targetedIndex: targetedIndex\n          }\n        }, true, namespace);\n      });\n    }\n\n    return namespace ? refineSingleIndexWithNamespace(searchState, nextRefinement, resetPage, namespace) : refineSingleIndex(searchState, nextRefinement, resetPage);\n  }\n}\n\nfunction refineMultiIndex(searchState, nextRefinement, indexId, resetPage) {\n  var page = resetPage ? {\n    page: 1\n  } : undefined;\n  var state = searchState.indices && searchState.indices[indexId] ? _objectSpread(_objectSpread({}, searchState.indices), {}, _defineProperty({}, indexId, _objectSpread(_objectSpread(_objectSpread({}, searchState.indices[indexId]), nextRefinement), page))) : _objectSpread(_objectSpread({}, searchState.indices), {}, _defineProperty({}, indexId, _objectSpread(_objectSpread({}, nextRefinement), page)));\n  return _objectSpread(_objectSpread({}, searchState), {}, {\n    indices: state\n  });\n}\n\nfunction refineSingleIndex(searchState, nextRefinement, resetPage) {\n  var page = resetPage ? {\n    page: 1\n  } : undefined;\n  return _objectSpread(_objectSpread(_objectSpread({}, searchState), nextRefinement), page);\n}\n\nfunction refineMultiIndexWithNamespace(searchState, nextRefinement, indexId, resetPage, namespace) {\n  var _objectSpread4;\n\n  var page = resetPage ? {\n    page: 1\n  } : undefined;\n  var state = searchState.indices && searchState.indices[indexId] ? _objectSpread(_objectSpread({}, searchState.indices), {}, _defineProperty({}, indexId, _objectSpread(_objectSpread({}, searchState.indices[indexId]), {}, (_objectSpread4 = {}, _defineProperty(_objectSpread4, namespace, _objectSpread(_objectSpread({}, searchState.indices[indexId][namespace]), nextRefinement)), _defineProperty(_objectSpread4, \"page\", 1), _objectSpread4)))) : _objectSpread(_objectSpread({}, searchState.indices), {}, _defineProperty({}, indexId, _objectSpread(_defineProperty({}, namespace, nextRefinement), page)));\n  return _objectSpread(_objectSpread({}, searchState), {}, {\n    indices: state\n  });\n}\n\nfunction refineSingleIndexWithNamespace(searchState, nextRefinement, resetPage, namespace) {\n  var page = resetPage ? {\n    page: 1\n  } : undefined;\n  return _objectSpread(_objectSpread({}, searchState), {}, _defineProperty({}, namespace, _objectSpread(_objectSpread({}, searchState[namespace]), nextRefinement)), page);\n}\n\nfunction getNamespaceAndAttributeName(id) {\n  var parts = id.match(/^([^.]*)\\.(.*)/);\n  var namespace = parts && parts[1];\n  var attributeName = parts && parts[2];\n  return {\n    namespace: namespace,\n    attributeName: attributeName\n  };\n}\n\nfunction hasRefinements(_ref) {\n  var multiIndex = _ref.multiIndex,\n      indexId = _ref.indexId,\n      namespace = _ref.namespace,\n      attributeName = _ref.attributeName,\n      id = _ref.id,\n      searchState = _ref.searchState;\n\n  if (multiIndex && namespace) {\n    return searchState.indices && searchState.indices[indexId] && searchState.indices[indexId][namespace] && Object.hasOwnProperty.call(searchState.indices[indexId][namespace], attributeName);\n  }\n\n  if (multiIndex) {\n    return searchState.indices && searchState.indices[indexId] && Object.hasOwnProperty.call(searchState.indices[indexId], id);\n  }\n\n  if (namespace) {\n    return searchState[namespace] && Object.hasOwnProperty.call(searchState[namespace], attributeName);\n  }\n\n  return Object.hasOwnProperty.call(searchState, id);\n}\n\nfunction getRefinements(_ref2) {\n  var multiIndex = _ref2.multiIndex,\n      indexId = _ref2.indexId,\n      namespace = _ref2.namespace,\n      attributeName = _ref2.attributeName,\n      id = _ref2.id,\n      searchState = _ref2.searchState;\n\n  if (multiIndex && namespace) {\n    return searchState.indices[indexId][namespace][attributeName];\n  }\n\n  if (multiIndex) {\n    return searchState.indices[indexId][id];\n  }\n\n  if (namespace) {\n    return searchState[namespace][attributeName];\n  }\n\n  return searchState[id];\n}\n\nexport function getCurrentRefinementValue(props, searchState, context, id, defaultValue) {\n  var indexId = getIndexId(context);\n\n  var _getNamespaceAndAttri = getNamespaceAndAttributeName(id),\n      namespace = _getNamespaceAndAttri.namespace,\n      attributeName = _getNamespaceAndAttri.attributeName;\n\n  var multiIndex = hasMultipleIndices(context);\n  var args = {\n    multiIndex: multiIndex,\n    indexId: indexId,\n    namespace: namespace,\n    attributeName: attributeName,\n    id: id,\n    searchState: searchState\n  };\n  var hasRefinementsValue = hasRefinements(args);\n\n  if (hasRefinementsValue) {\n    return getRefinements(args);\n  }\n\n  if (props.defaultRefinement) {\n    return props.defaultRefinement;\n  }\n\n  return defaultValue;\n}\nexport function cleanUpValue(searchState, context, id) {\n  var indexId = getIndexId(context);\n\n  var _getNamespaceAndAttri2 = getNamespaceAndAttributeName(id),\n      namespace = _getNamespaceAndAttri2.namespace,\n      attributeName = _getNamespaceAndAttri2.attributeName;\n\n  if (hasMultipleIndices(context) && Boolean(searchState.indices)) {\n    return cleanUpValueWithMultiIndex({\n      attribute: attributeName,\n      searchState: searchState,\n      indexId: indexId,\n      id: id,\n      namespace: namespace\n    });\n  }\n\n  return cleanUpValueWithSingleIndex({\n    attribute: attributeName,\n    searchState: searchState,\n    id: id,\n    namespace: namespace\n  });\n}\n\nfunction cleanUpValueWithSingleIndex(_ref3) {\n  var searchState = _ref3.searchState,\n      id = _ref3.id,\n      namespace = _ref3.namespace,\n      attribute = _ref3.attribute;\n\n  if (namespace) {\n    return _objectSpread(_objectSpread({}, searchState), {}, _defineProperty({}, namespace, omit(searchState[namespace], [attribute])));\n  }\n\n  return omit(searchState, [id]);\n}\n\nfunction cleanUpValueWithMultiIndex(_ref4) {\n  var searchState = _ref4.searchState,\n      indexId = _ref4.indexId,\n      id = _ref4.id,\n      namespace = _ref4.namespace,\n      attribute = _ref4.attribute;\n  var indexSearchState = searchState.indices[indexId];\n\n  if (namespace && indexSearchState) {\n    return _objectSpread(_objectSpread({}, searchState), {}, {\n      indices: _objectSpread(_objectSpread({}, searchState.indices), {}, _defineProperty({}, indexId, _objectSpread(_objectSpread({}, indexSearchState), {}, _defineProperty({}, namespace, omit(indexSearchState[namespace], [attribute])))))\n    });\n  }\n\n  if (indexSearchState) {\n    return _objectSpread(_objectSpread({}, searchState), {}, {\n      indices: _objectSpread(_objectSpread({}, searchState.indices), {}, _defineProperty({}, indexId, omit(indexSearchState, [id])))\n    });\n  }\n\n  return searchState;\n}","map":{"version":3,"sources":["/Users/tingting/code/tin2294/repository-search/node_modules/react-instantsearch-core/dist/es/core/indexUtils.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","omit","getIndexId","context","hasMultipleIndices","multiIndexContext","targetedIndex","ais","mainTargetedIndex","getResults","searchResults","results","hits","indexId","refineValue","searchState","nextRefinement","resetPage","namespace","refineMultiIndexWithNamespace","refineMultiIndex","indices","page","refineSingleIndexWithNamespace","refineSingleIndex","undefined","state","_objectSpread4","getNamespaceAndAttributeName","id","parts","match","attributeName","hasRefinements","_ref","multiIndex","hasOwnProperty","call","getRefinements","_ref2","getCurrentRefinementValue","props","defaultValue","_getNamespaceAndAttri","args","hasRefinementsValue","defaultRefinement","cleanUpValue","_getNamespaceAndAttri2","Boolean","cleanUpValueWithMultiIndex","attribute","cleanUpValueWithSingleIndex","_ref3","_ref4","indexSearchState"],"mappings":"AAAA,OAAOA,eAAP,MAA4B,2CAA5B;;AAEA,SAASC,OAAT,CAAiBC,MAAjB,EAAyBC,cAAzB,EAAyC;AAAE,MAAIC,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYF,MAAZ,CAAX;;AAAgC,MAAIG,MAAM,CAACC,qBAAX,EAAkC;AAAE,QAAIC,OAAO,GAAGF,MAAM,CAACC,qBAAP,CAA6BJ,MAA7B,CAAd;;AAAoD,QAAIC,cAAJ,EAAoB;AAAEI,MAAAA,OAAO,GAAGA,OAAO,CAACC,MAAR,CAAe,UAAUC,GAAV,EAAe;AAAE,eAAOJ,MAAM,CAACK,wBAAP,CAAgCR,MAAhC,EAAwCO,GAAxC,EAA6CE,UAApD;AAAiE,OAAjG,CAAV;AAA+G;;AAACP,IAAAA,IAAI,CAACQ,IAAL,CAAUC,KAAV,CAAgBT,IAAhB,EAAsBG,OAAtB;AAAiC;;AAAC,SAAOH,IAAP;AAAc;;AAEzV,SAASU,aAAT,CAAuBC,MAAvB,EAA+B;AAAE,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGC,SAAS,CAACC,MAA9B,EAAsCF,CAAC,EAAvC,EAA2C;AAAE,QAAIG,MAAM,GAAGF,SAAS,CAACD,CAAD,CAAT,IAAgB,IAAhB,GAAuBC,SAAS,CAACD,CAAD,CAAhC,GAAsC,EAAnD;;AAAuD,QAAIA,CAAC,GAAG,CAAR,EAAW;AAAEf,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,EAAiB,IAAjB,CAAP,CAA8BC,OAA9B,CAAsC,UAAUC,GAAV,EAAe;AAAErB,QAAAA,eAAe,CAACe,MAAD,EAASM,GAAT,EAAcF,MAAM,CAACE,GAAD,CAApB,CAAf;AAA4C,OAAnG;AAAuG,KAApH,MAA0H,IAAIhB,MAAM,CAACiB,yBAAX,EAAsC;AAAEjB,MAAAA,MAAM,CAACkB,gBAAP,CAAwBR,MAAxB,EAAgCV,MAAM,CAACiB,yBAAP,CAAiCH,MAAjC,CAAhC;AAA4E,KAApH,MAA0H;AAAElB,MAAAA,OAAO,CAACI,MAAM,CAACc,MAAD,CAAP,CAAP,CAAwBC,OAAxB,CAAgC,UAAUC,GAAV,EAAe;AAAEhB,QAAAA,MAAM,CAACmB,cAAP,CAAsBT,MAAtB,EAA8BM,GAA9B,EAAmChB,MAAM,CAACK,wBAAP,CAAgCS,MAAhC,EAAwCE,GAAxC,CAAnC;AAAmF,OAApI;AAAwI;AAAE;;AAAC,SAAON,MAAP;AAAgB;;AAEthB,SAASU,IAAT,QAAqB,YAArB;AACA,OAAO,SAASC,UAAT,CAAoBC,OAApB,EAA6B;AAClC,SAAOC,kBAAkB,CAACD,OAAD,CAAlB,GAA8BA,OAAO,CAACE,iBAAR,CAA0BC,aAAxD,GAAwEH,OAAO,CAACI,GAAR,CAAYC,iBAA3F;AACD;AACD;AACA;AACA;;AAEA,OAAO,SAASC,UAAT,CAAoBC,aAApB,EAAmCP,OAAnC,EAA4C;AACjD,MAAIO,aAAa,CAACC,OAAlB,EAA2B;AACzB,QAAID,aAAa,CAACC,OAAd,CAAsBC,IAA1B,EAAgC;AAC9B,aAAOF,aAAa,CAACC,OAArB;AACD;;AAED,QAAIE,OAAO,GAAGX,UAAU,CAACC,OAAD,CAAxB;;AAEA,QAAIO,aAAa,CAACC,OAAd,CAAsBE,OAAtB,CAAJ,EAAoC;AAClC,aAAOH,aAAa,CAACC,OAAd,CAAsBE,OAAtB,CAAP;AACD;AACF;;AAED,SAAO,IAAP;AACD;AACD,OAAO,SAAST,kBAAT,CAA4BD,OAA5B,EAAqC;AAC1C,SAAOA,OAAO,IAAIA,OAAO,CAACE,iBAA1B;AACD;AACD,OAAO,SAASS,WAAT,CAAqBC,WAArB,EAAkCC,cAAlC,EAAkDb,OAAlD,EAA2Dc,SAA3D,EAAsEC,SAAtE,EAAiF;AACtF,MAAId,kBAAkB,CAACD,OAAD,CAAtB,EAAiC;AAC/B,QAAIU,OAAO,GAAGX,UAAU,CAACC,OAAD,CAAxB;AACA,WAAOe,SAAS,GAAGC,6BAA6B,CAACJ,WAAD,EAAcC,cAAd,EAA8BH,OAA9B,EAAuCI,SAAvC,EAAkDC,SAAlD,CAAhC,GAA+FE,gBAAgB,CAACL,WAAD,EAAcC,cAAd,EAA8BH,OAA9B,EAAuCI,SAAvC,CAA/H;AACD,GAHD,MAGO;AACL;AACA;AACA;AACA;AACA;AACA,QAAIF,WAAW,CAACM,OAAZ,IAAuBJ,SAA3B,EAAsC;AACpCpC,MAAAA,MAAM,CAACD,IAAP,CAAYmC,WAAW,CAACM,OAAxB,EAAiCzB,OAAjC,CAAyC,UAAUU,aAAV,EAAyB;AAChES,QAAAA,WAAW,GAAGD,WAAW,CAACC,WAAD,EAAc;AACrCO,UAAAA,IAAI,EAAE;AAD+B,SAAd,EAEtB;AACDjB,UAAAA,iBAAiB,EAAE;AACjBC,YAAAA,aAAa,EAAEA;AADE;AADlB,SAFsB,EAMtB,IANsB,EAMhBY,SANgB,CAAzB;AAOD,OARD;AASD;;AAED,WAAOA,SAAS,GAAGK,8BAA8B,CAACR,WAAD,EAAcC,cAAd,EAA8BC,SAA9B,EAAyCC,SAAzC,CAAjC,GAAuFM,iBAAiB,CAACT,WAAD,EAAcC,cAAd,EAA8BC,SAA9B,CAAxH;AACD;AACF;;AAED,SAASG,gBAAT,CAA0BL,WAA1B,EAAuCC,cAAvC,EAAuDH,OAAvD,EAAgEI,SAAhE,EAA2E;AACzE,MAAIK,IAAI,GAAGL,SAAS,GAAG;AACrBK,IAAAA,IAAI,EAAE;AADe,GAAH,GAEhBG,SAFJ;AAGA,MAAIC,KAAK,GAAGX,WAAW,CAACM,OAAZ,IAAuBN,WAAW,CAACM,OAAZ,CAAoBR,OAApB,CAAvB,GAAsDvB,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKyB,WAAW,CAACM,OAAjB,CAAd,EAAyC,EAAzC,EAA6C7C,eAAe,CAAC,EAAD,EAAKqC,OAAL,EAAcvB,aAAa,CAACA,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKyB,WAAW,CAACM,OAAZ,CAAoBR,OAApB,CAAL,CAAd,EAAkDG,cAAlD,CAAd,EAAiFM,IAAjF,CAA3B,CAA5D,CAAnE,GAAqPhC,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKyB,WAAW,CAACM,OAAjB,CAAd,EAAyC,EAAzC,EAA6C7C,eAAe,CAAC,EAAD,EAAKqC,OAAL,EAAcvB,aAAa,CAACA,aAAa,CAAC,EAAD,EAAK0B,cAAL,CAAd,EAAoCM,IAApC,CAA3B,CAA5D,CAA9Q;AACA,SAAOhC,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKyB,WAAL,CAAd,EAAiC,EAAjC,EAAqC;AACvDM,IAAAA,OAAO,EAAEK;AAD8C,GAArC,CAApB;AAGD;;AAED,SAASF,iBAAT,CAA2BT,WAA3B,EAAwCC,cAAxC,EAAwDC,SAAxD,EAAmE;AACjE,MAAIK,IAAI,GAAGL,SAAS,GAAG;AACrBK,IAAAA,IAAI,EAAE;AADe,GAAH,GAEhBG,SAFJ;AAGA,SAAOnC,aAAa,CAACA,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKyB,WAAL,CAAd,EAAiCC,cAAjC,CAAd,EAAgEM,IAAhE,CAApB;AACD;;AAED,SAASH,6BAAT,CAAuCJ,WAAvC,EAAoDC,cAApD,EAAoEH,OAApE,EAA6EI,SAA7E,EAAwFC,SAAxF,EAAmG;AACjG,MAAIS,cAAJ;;AAEA,MAAIL,IAAI,GAAGL,SAAS,GAAG;AACrBK,IAAAA,IAAI,EAAE;AADe,GAAH,GAEhBG,SAFJ;AAGA,MAAIC,KAAK,GAAGX,WAAW,CAACM,OAAZ,IAAuBN,WAAW,CAACM,OAAZ,CAAoBR,OAApB,CAAvB,GAAsDvB,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKyB,WAAW,CAACM,OAAjB,CAAd,EAAyC,EAAzC,EAA6C7C,eAAe,CAAC,EAAD,EAAKqC,OAAL,EAAcvB,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKyB,WAAW,CAACM,OAAZ,CAAoBR,OAApB,CAAL,CAAd,EAAkD,EAAlD,GAAuDc,cAAc,GAAG,EAAjB,EAAqBnD,eAAe,CAACmD,cAAD,EAAiBT,SAAjB,EAA4B5B,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKyB,WAAW,CAACM,OAAZ,CAAoBR,OAApB,EAA6BK,SAA7B,CAAL,CAAd,EAA6DF,cAA7D,CAAzC,CAApC,EAA4JxC,eAAe,CAACmD,cAAD,EAAiB,MAAjB,EAAyB,CAAzB,CAA3K,EAAwMA,cAA/P,EAA3B,CAA5D,CAAnE,GAA8arC,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKyB,WAAW,CAACM,OAAjB,CAAd,EAAyC,EAAzC,EAA6C7C,eAAe,CAAC,EAAD,EAAKqC,OAAL,EAAcvB,aAAa,CAACd,eAAe,CAAC,EAAD,EAAK0C,SAAL,EAAgBF,cAAhB,CAAhB,EAAiDM,IAAjD,CAA3B,CAA5D,CAAvc;AACA,SAAOhC,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKyB,WAAL,CAAd,EAAiC,EAAjC,EAAqC;AACvDM,IAAAA,OAAO,EAAEK;AAD8C,GAArC,CAApB;AAGD;;AAED,SAASH,8BAAT,CAAwCR,WAAxC,EAAqDC,cAArD,EAAqEC,SAArE,EAAgFC,SAAhF,EAA2F;AACzF,MAAII,IAAI,GAAGL,SAAS,GAAG;AACrBK,IAAAA,IAAI,EAAE;AADe,GAAH,GAEhBG,SAFJ;AAGA,SAAOnC,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKyB,WAAL,CAAd,EAAiC,EAAjC,EAAqCvC,eAAe,CAAC,EAAD,EAAK0C,SAAL,EAAgB5B,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKyB,WAAW,CAACG,SAAD,CAAhB,CAAd,EAA4CF,cAA5C,CAA7B,CAApD,EAA+IM,IAA/I,CAApB;AACD;;AAED,SAASM,4BAAT,CAAsCC,EAAtC,EAA0C;AACxC,MAAIC,KAAK,GAAGD,EAAE,CAACE,KAAH,CAAS,gBAAT,CAAZ;AACA,MAAIb,SAAS,GAAGY,KAAK,IAAIA,KAAK,CAAC,CAAD,CAA9B;AACA,MAAIE,aAAa,GAAGF,KAAK,IAAIA,KAAK,CAAC,CAAD,CAAlC;AACA,SAAO;AACLZ,IAAAA,SAAS,EAAEA,SADN;AAELc,IAAAA,aAAa,EAAEA;AAFV,GAAP;AAID;;AAED,SAASC,cAAT,CAAwBC,IAAxB,EAA8B;AAC5B,MAAIC,UAAU,GAAGD,IAAI,CAACC,UAAtB;AAAA,MACItB,OAAO,GAAGqB,IAAI,CAACrB,OADnB;AAAA,MAEIK,SAAS,GAAGgB,IAAI,CAAChB,SAFrB;AAAA,MAGIc,aAAa,GAAGE,IAAI,CAACF,aAHzB;AAAA,MAIIH,EAAE,GAAGK,IAAI,CAACL,EAJd;AAAA,MAKId,WAAW,GAAGmB,IAAI,CAACnB,WALvB;;AAOA,MAAIoB,UAAU,IAAIjB,SAAlB,EAA6B;AAC3B,WAAOH,WAAW,CAACM,OAAZ,IAAuBN,WAAW,CAACM,OAAZ,CAAoBR,OAApB,CAAvB,IAAuDE,WAAW,CAACM,OAAZ,CAAoBR,OAApB,EAA6BK,SAA7B,CAAvD,IAAkGrC,MAAM,CAACuD,cAAP,CAAsBC,IAAtB,CAA2BtB,WAAW,CAACM,OAAZ,CAAoBR,OAApB,EAA6BK,SAA7B,CAA3B,EAAoEc,aAApE,CAAzG;AACD;;AAED,MAAIG,UAAJ,EAAgB;AACd,WAAOpB,WAAW,CAACM,OAAZ,IAAuBN,WAAW,CAACM,OAAZ,CAAoBR,OAApB,CAAvB,IAAuDhC,MAAM,CAACuD,cAAP,CAAsBC,IAAtB,CAA2BtB,WAAW,CAACM,OAAZ,CAAoBR,OAApB,CAA3B,EAAyDgB,EAAzD,CAA9D;AACD;;AAED,MAAIX,SAAJ,EAAe;AACb,WAAOH,WAAW,CAACG,SAAD,CAAX,IAA0BrC,MAAM,CAACuD,cAAP,CAAsBC,IAAtB,CAA2BtB,WAAW,CAACG,SAAD,CAAtC,EAAmDc,aAAnD,CAAjC;AACD;;AAED,SAAOnD,MAAM,CAACuD,cAAP,CAAsBC,IAAtB,CAA2BtB,WAA3B,EAAwCc,EAAxC,CAAP;AACD;;AAED,SAASS,cAAT,CAAwBC,KAAxB,EAA+B;AAC7B,MAAIJ,UAAU,GAAGI,KAAK,CAACJ,UAAvB;AAAA,MACItB,OAAO,GAAG0B,KAAK,CAAC1B,OADpB;AAAA,MAEIK,SAAS,GAAGqB,KAAK,CAACrB,SAFtB;AAAA,MAGIc,aAAa,GAAGO,KAAK,CAACP,aAH1B;AAAA,MAIIH,EAAE,GAAGU,KAAK,CAACV,EAJf;AAAA,MAKId,WAAW,GAAGwB,KAAK,CAACxB,WALxB;;AAOA,MAAIoB,UAAU,IAAIjB,SAAlB,EAA6B;AAC3B,WAAOH,WAAW,CAACM,OAAZ,CAAoBR,OAApB,EAA6BK,SAA7B,EAAwCc,aAAxC,CAAP;AACD;;AAED,MAAIG,UAAJ,EAAgB;AACd,WAAOpB,WAAW,CAACM,OAAZ,CAAoBR,OAApB,EAA6BgB,EAA7B,CAAP;AACD;;AAED,MAAIX,SAAJ,EAAe;AACb,WAAOH,WAAW,CAACG,SAAD,CAAX,CAAuBc,aAAvB,CAAP;AACD;;AAED,SAAOjB,WAAW,CAACc,EAAD,CAAlB;AACD;;AAED,OAAO,SAASW,yBAAT,CAAmCC,KAAnC,EAA0C1B,WAA1C,EAAuDZ,OAAvD,EAAgE0B,EAAhE,EAAoEa,YAApE,EAAkF;AACvF,MAAI7B,OAAO,GAAGX,UAAU,CAACC,OAAD,CAAxB;;AAEA,MAAIwC,qBAAqB,GAAGf,4BAA4B,CAACC,EAAD,CAAxD;AAAA,MACIX,SAAS,GAAGyB,qBAAqB,CAACzB,SADtC;AAAA,MAEIc,aAAa,GAAGW,qBAAqB,CAACX,aAF1C;;AAIA,MAAIG,UAAU,GAAG/B,kBAAkB,CAACD,OAAD,CAAnC;AACA,MAAIyC,IAAI,GAAG;AACTT,IAAAA,UAAU,EAAEA,UADH;AAETtB,IAAAA,OAAO,EAAEA,OAFA;AAGTK,IAAAA,SAAS,EAAEA,SAHF;AAITc,IAAAA,aAAa,EAAEA,aAJN;AAKTH,IAAAA,EAAE,EAAEA,EALK;AAMTd,IAAAA,WAAW,EAAEA;AANJ,GAAX;AAQA,MAAI8B,mBAAmB,GAAGZ,cAAc,CAACW,IAAD,CAAxC;;AAEA,MAAIC,mBAAJ,EAAyB;AACvB,WAAOP,cAAc,CAACM,IAAD,CAArB;AACD;;AAED,MAAIH,KAAK,CAACK,iBAAV,EAA6B;AAC3B,WAAOL,KAAK,CAACK,iBAAb;AACD;;AAED,SAAOJ,YAAP;AACD;AACD,OAAO,SAASK,YAAT,CAAsBhC,WAAtB,EAAmCZ,OAAnC,EAA4C0B,EAA5C,EAAgD;AACrD,MAAIhB,OAAO,GAAGX,UAAU,CAACC,OAAD,CAAxB;;AAEA,MAAI6C,sBAAsB,GAAGpB,4BAA4B,CAACC,EAAD,CAAzD;AAAA,MACIX,SAAS,GAAG8B,sBAAsB,CAAC9B,SADvC;AAAA,MAEIc,aAAa,GAAGgB,sBAAsB,CAAChB,aAF3C;;AAIA,MAAI5B,kBAAkB,CAACD,OAAD,CAAlB,IAA+B8C,OAAO,CAAClC,WAAW,CAACM,OAAb,CAA1C,EAAiE;AAC/D,WAAO6B,0BAA0B,CAAC;AAChCC,MAAAA,SAAS,EAAEnB,aADqB;AAEhCjB,MAAAA,WAAW,EAAEA,WAFmB;AAGhCF,MAAAA,OAAO,EAAEA,OAHuB;AAIhCgB,MAAAA,EAAE,EAAEA,EAJ4B;AAKhCX,MAAAA,SAAS,EAAEA;AALqB,KAAD,CAAjC;AAOD;;AAED,SAAOkC,2BAA2B,CAAC;AACjCD,IAAAA,SAAS,EAAEnB,aADsB;AAEjCjB,IAAAA,WAAW,EAAEA,WAFoB;AAGjCc,IAAAA,EAAE,EAAEA,EAH6B;AAIjCX,IAAAA,SAAS,EAAEA;AAJsB,GAAD,CAAlC;AAMD;;AAED,SAASkC,2BAAT,CAAqCC,KAArC,EAA4C;AAC1C,MAAItC,WAAW,GAAGsC,KAAK,CAACtC,WAAxB;AAAA,MACIc,EAAE,GAAGwB,KAAK,CAACxB,EADf;AAAA,MAEIX,SAAS,GAAGmC,KAAK,CAACnC,SAFtB;AAAA,MAGIiC,SAAS,GAAGE,KAAK,CAACF,SAHtB;;AAKA,MAAIjC,SAAJ,EAAe;AACb,WAAO5B,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKyB,WAAL,CAAd,EAAiC,EAAjC,EAAqCvC,eAAe,CAAC,EAAD,EAAK0C,SAAL,EAAgBjB,IAAI,CAACc,WAAW,CAACG,SAAD,CAAZ,EAAyB,CAACiC,SAAD,CAAzB,CAApB,CAApD,CAApB;AACD;;AAED,SAAOlD,IAAI,CAACc,WAAD,EAAc,CAACc,EAAD,CAAd,CAAX;AACD;;AAED,SAASqB,0BAAT,CAAoCI,KAApC,EAA2C;AACzC,MAAIvC,WAAW,GAAGuC,KAAK,CAACvC,WAAxB;AAAA,MACIF,OAAO,GAAGyC,KAAK,CAACzC,OADpB;AAAA,MAEIgB,EAAE,GAAGyB,KAAK,CAACzB,EAFf;AAAA,MAGIX,SAAS,GAAGoC,KAAK,CAACpC,SAHtB;AAAA,MAIIiC,SAAS,GAAGG,KAAK,CAACH,SAJtB;AAKA,MAAII,gBAAgB,GAAGxC,WAAW,CAACM,OAAZ,CAAoBR,OAApB,CAAvB;;AAEA,MAAIK,SAAS,IAAIqC,gBAAjB,EAAmC;AACjC,WAAOjE,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKyB,WAAL,CAAd,EAAiC,EAAjC,EAAqC;AACvDM,MAAAA,OAAO,EAAE/B,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKyB,WAAW,CAACM,OAAjB,CAAd,EAAyC,EAAzC,EAA6C7C,eAAe,CAAC,EAAD,EAAKqC,OAAL,EAAcvB,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKiE,gBAAL,CAAd,EAAsC,EAAtC,EAA0C/E,eAAe,CAAC,EAAD,EAAK0C,SAAL,EAAgBjB,IAAI,CAACsD,gBAAgB,CAACrC,SAAD,CAAjB,EAA8B,CAACiC,SAAD,CAA9B,CAApB,CAAzD,CAA3B,CAA5D;AADiC,KAArC,CAApB;AAGD;;AAED,MAAII,gBAAJ,EAAsB;AACpB,WAAOjE,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKyB,WAAL,CAAd,EAAiC,EAAjC,EAAqC;AACvDM,MAAAA,OAAO,EAAE/B,aAAa,CAACA,aAAa,CAAC,EAAD,EAAKyB,WAAW,CAACM,OAAjB,CAAd,EAAyC,EAAzC,EAA6C7C,eAAe,CAAC,EAAD,EAAKqC,OAAL,EAAcZ,IAAI,CAACsD,gBAAD,EAAmB,CAAC1B,EAAD,CAAnB,CAAlB,CAA5D;AADiC,KAArC,CAApB;AAGD;;AAED,SAAOd,WAAP;AACD","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { omit } from \"./utils.js\";\nexport function getIndexId(context) {\n  return hasMultipleIndices(context) ? context.multiIndexContext.targetedIndex : context.ais.mainTargetedIndex;\n}\n/**\n * @returns {import('algoliasearch-helper').SearchResults} results\n */\n\nexport function getResults(searchResults, context) {\n  if (searchResults.results) {\n    if (searchResults.results.hits) {\n      return searchResults.results;\n    }\n\n    var indexId = getIndexId(context);\n\n    if (searchResults.results[indexId]) {\n      return searchResults.results[indexId];\n    }\n  }\n\n  return null;\n}\nexport function hasMultipleIndices(context) {\n  return context && context.multiIndexContext;\n}\nexport function refineValue(searchState, nextRefinement, context, resetPage, namespace) {\n  if (hasMultipleIndices(context)) {\n    var indexId = getIndexId(context);\n    return namespace ? refineMultiIndexWithNamespace(searchState, nextRefinement, indexId, resetPage, namespace) : refineMultiIndex(searchState, nextRefinement, indexId, resetPage);\n  } else {\n    // When we have a multi index page with shared widgets we should also\n    // reset their page to 1 if the resetPage is provided. Otherwise the\n    // indices will always be reset\n    // see: https://github.com/algolia/react-instantsearch/issues/310\n    // see: https://github.com/algolia/react-instantsearch/issues/637\n    if (searchState.indices && resetPage) {\n      Object.keys(searchState.indices).forEach(function (targetedIndex) {\n        searchState = refineValue(searchState, {\n          page: 1\n        }, {\n          multiIndexContext: {\n            targetedIndex: targetedIndex\n          }\n        }, true, namespace);\n      });\n    }\n\n    return namespace ? refineSingleIndexWithNamespace(searchState, nextRefinement, resetPage, namespace) : refineSingleIndex(searchState, nextRefinement, resetPage);\n  }\n}\n\nfunction refineMultiIndex(searchState, nextRefinement, indexId, resetPage) {\n  var page = resetPage ? {\n    page: 1\n  } : undefined;\n  var state = searchState.indices && searchState.indices[indexId] ? _objectSpread(_objectSpread({}, searchState.indices), {}, _defineProperty({}, indexId, _objectSpread(_objectSpread(_objectSpread({}, searchState.indices[indexId]), nextRefinement), page))) : _objectSpread(_objectSpread({}, searchState.indices), {}, _defineProperty({}, indexId, _objectSpread(_objectSpread({}, nextRefinement), page)));\n  return _objectSpread(_objectSpread({}, searchState), {}, {\n    indices: state\n  });\n}\n\nfunction refineSingleIndex(searchState, nextRefinement, resetPage) {\n  var page = resetPage ? {\n    page: 1\n  } : undefined;\n  return _objectSpread(_objectSpread(_objectSpread({}, searchState), nextRefinement), page);\n}\n\nfunction refineMultiIndexWithNamespace(searchState, nextRefinement, indexId, resetPage, namespace) {\n  var _objectSpread4;\n\n  var page = resetPage ? {\n    page: 1\n  } : undefined;\n  var state = searchState.indices && searchState.indices[indexId] ? _objectSpread(_objectSpread({}, searchState.indices), {}, _defineProperty({}, indexId, _objectSpread(_objectSpread({}, searchState.indices[indexId]), {}, (_objectSpread4 = {}, _defineProperty(_objectSpread4, namespace, _objectSpread(_objectSpread({}, searchState.indices[indexId][namespace]), nextRefinement)), _defineProperty(_objectSpread4, \"page\", 1), _objectSpread4)))) : _objectSpread(_objectSpread({}, searchState.indices), {}, _defineProperty({}, indexId, _objectSpread(_defineProperty({}, namespace, nextRefinement), page)));\n  return _objectSpread(_objectSpread({}, searchState), {}, {\n    indices: state\n  });\n}\n\nfunction refineSingleIndexWithNamespace(searchState, nextRefinement, resetPage, namespace) {\n  var page = resetPage ? {\n    page: 1\n  } : undefined;\n  return _objectSpread(_objectSpread({}, searchState), {}, _defineProperty({}, namespace, _objectSpread(_objectSpread({}, searchState[namespace]), nextRefinement)), page);\n}\n\nfunction getNamespaceAndAttributeName(id) {\n  var parts = id.match(/^([^.]*)\\.(.*)/);\n  var namespace = parts && parts[1];\n  var attributeName = parts && parts[2];\n  return {\n    namespace: namespace,\n    attributeName: attributeName\n  };\n}\n\nfunction hasRefinements(_ref) {\n  var multiIndex = _ref.multiIndex,\n      indexId = _ref.indexId,\n      namespace = _ref.namespace,\n      attributeName = _ref.attributeName,\n      id = _ref.id,\n      searchState = _ref.searchState;\n\n  if (multiIndex && namespace) {\n    return searchState.indices && searchState.indices[indexId] && searchState.indices[indexId][namespace] && Object.hasOwnProperty.call(searchState.indices[indexId][namespace], attributeName);\n  }\n\n  if (multiIndex) {\n    return searchState.indices && searchState.indices[indexId] && Object.hasOwnProperty.call(searchState.indices[indexId], id);\n  }\n\n  if (namespace) {\n    return searchState[namespace] && Object.hasOwnProperty.call(searchState[namespace], attributeName);\n  }\n\n  return Object.hasOwnProperty.call(searchState, id);\n}\n\nfunction getRefinements(_ref2) {\n  var multiIndex = _ref2.multiIndex,\n      indexId = _ref2.indexId,\n      namespace = _ref2.namespace,\n      attributeName = _ref2.attributeName,\n      id = _ref2.id,\n      searchState = _ref2.searchState;\n\n  if (multiIndex && namespace) {\n    return searchState.indices[indexId][namespace][attributeName];\n  }\n\n  if (multiIndex) {\n    return searchState.indices[indexId][id];\n  }\n\n  if (namespace) {\n    return searchState[namespace][attributeName];\n  }\n\n  return searchState[id];\n}\n\nexport function getCurrentRefinementValue(props, searchState, context, id, defaultValue) {\n  var indexId = getIndexId(context);\n\n  var _getNamespaceAndAttri = getNamespaceAndAttributeName(id),\n      namespace = _getNamespaceAndAttri.namespace,\n      attributeName = _getNamespaceAndAttri.attributeName;\n\n  var multiIndex = hasMultipleIndices(context);\n  var args = {\n    multiIndex: multiIndex,\n    indexId: indexId,\n    namespace: namespace,\n    attributeName: attributeName,\n    id: id,\n    searchState: searchState\n  };\n  var hasRefinementsValue = hasRefinements(args);\n\n  if (hasRefinementsValue) {\n    return getRefinements(args);\n  }\n\n  if (props.defaultRefinement) {\n    return props.defaultRefinement;\n  }\n\n  return defaultValue;\n}\nexport function cleanUpValue(searchState, context, id) {\n  var indexId = getIndexId(context);\n\n  var _getNamespaceAndAttri2 = getNamespaceAndAttributeName(id),\n      namespace = _getNamespaceAndAttri2.namespace,\n      attributeName = _getNamespaceAndAttri2.attributeName;\n\n  if (hasMultipleIndices(context) && Boolean(searchState.indices)) {\n    return cleanUpValueWithMultiIndex({\n      attribute: attributeName,\n      searchState: searchState,\n      indexId: indexId,\n      id: id,\n      namespace: namespace\n    });\n  }\n\n  return cleanUpValueWithSingleIndex({\n    attribute: attributeName,\n    searchState: searchState,\n    id: id,\n    namespace: namespace\n  });\n}\n\nfunction cleanUpValueWithSingleIndex(_ref3) {\n  var searchState = _ref3.searchState,\n      id = _ref3.id,\n      namespace = _ref3.namespace,\n      attribute = _ref3.attribute;\n\n  if (namespace) {\n    return _objectSpread(_objectSpread({}, searchState), {}, _defineProperty({}, namespace, omit(searchState[namespace], [attribute])));\n  }\n\n  return omit(searchState, [id]);\n}\n\nfunction cleanUpValueWithMultiIndex(_ref4) {\n  var searchState = _ref4.searchState,\n      indexId = _ref4.indexId,\n      id = _ref4.id,\n      namespace = _ref4.namespace,\n      attribute = _ref4.attribute;\n  var indexSearchState = searchState.indices[indexId];\n\n  if (namespace && indexSearchState) {\n    return _objectSpread(_objectSpread({}, searchState), {}, {\n      indices: _objectSpread(_objectSpread({}, searchState.indices), {}, _defineProperty({}, indexId, _objectSpread(_objectSpread({}, indexSearchState), {}, _defineProperty({}, namespace, omit(indexSearchState[namespace], [attribute])))))\n    });\n  }\n\n  if (indexSearchState) {\n    return _objectSpread(_objectSpread({}, searchState), {}, {\n      indices: _objectSpread(_objectSpread({}, searchState.indices), {}, _defineProperty({}, indexId, omit(indexSearchState, [id])))\n    });\n  }\n\n  return searchState;\n}"]},"metadata":{},"sourceType":"module"}